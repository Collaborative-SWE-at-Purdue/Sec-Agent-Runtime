## System Interaction Model

### Overview

The system consists of two main components:

- **Agent (LLM)**: The agent serves as a bidirectional interface between the user and the runtime.
- **Runtime**: validates, authorizes, executes, and logs actions.

The runtime treats the agent as **untrusted** and enforces strict validation and authorization on all actions.
The system operates as a request–response loop between the agent and the runtime:
Agent → INPUT → Runtime → RESPONSE → Agent

---

### Interaction Flow

The overall interaction follows this flow:

Agent → INPUT → Runtime → RESPONSE → Agent

1. The agent generates a structured input (JSON)
2. The input is sent to the runtime
3. The runtime processes the input through a deterministic execution pipeline
4. The runtime produces a decision:
   - **ALLOW** if all validation and policy checks pass
   - **DENY** if any validation or policy check fails
5. The runtime records the full processing details in an internal log
6. The runtime returns a minimal response containing the decision (ALLOW or DENY)
7. The agent may generate further inputs based on the response, forming a loop

The response only exposes the decision (ALLOW or DENY), while detailed failure information is recorded in the internal audit log and not exposed to the agent.

---

### Roles and Responsibilities


#### Agent (LLM)

- Interprets user intent
- Generates structured proposals
- Acts as an **untrusted component**
- May produce incorrect or malicious outputs

#### Runtime

- Acts as a **security boundary** between the agent and the environment
- Treats the agent as untrusted
- Validates all incoming proposals against a strict schema
- Enforces policy using an allowlist and sandbox restrictions
- Executes only authorized actions
- Produces deterministic and auditable outcomes
For detailed processing logic, refer to the Step Lifecycle Phases section.


### Request–Response Model

The runtime follows a strict request–response model:

Agent → PROPOSAL → Runtime → RESPONSE → Agent

- Each proposal corresponds to exactly one step
- Each step produces exactly one response
- No partial or streaming responses are allowed

---

### Proposal

A proposal is a structured JSON payload generated by the agent.

Example:

```json
{
  "schema_version": "1.0.0",
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "reasoning": "Need to read configuration file",
  "action": "READ_FILE",
  "args": {
    "path": "/sandbox/config.txt"
  }
}

```

### Agent-to-User Response

The runtime returns structured JSON responses to the agent.

The agent translates these responses into human-readable output for the user.

Examples:

#### Successful Execution

```json
{
  "runtime_response": {
    "proposal_id": "123",
    "action": "READ_FILE",
    "outcome": "SUCCESS",
    "result": {
      "content": "Hello World"
    },
    "error": null
  },
  "agent_output": "The file content is:\n\nHello World"
}

```

#### Policy Denied

```json
{
  "runtime_response": {
    "proposal_id": "124",
    "action": "DELETE_FILE",
    "outcome": "DENIED",
    "result": null,
    "error": {
      "error_code": "POLICY_VIOLATION",
      "message": "Access outside /sandbox/ is not allowed"
    }
  },
  "agent_output": "The requested action is not allowed due to security restrictions."
}

```

#### Execution Error

```json
{
  "runtime_response": {
    "proposal_id": "125",
    "action": "READ_FILE",
    "outcome": "EXECUTION_ERROR",
    "result": null,
    "error": {
      "error_code": "EXECUTION_ERROR",
      "message": "File not found"
    }
  },
  "agent_output": "The file could not be found."
}
```

