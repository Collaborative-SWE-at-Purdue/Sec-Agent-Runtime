## Step Lifecycle Phases

## Overview

A **step** is one processing cycle where the runtime handles an agent-generated **Proposal** (JSON), executing:

**RECEIVE → PARSE → VALIDATE → AUTHORIZE → EXECUTE → RECORD → RESPOND**

**Rules**
- A step MUST execute **at most one** action.
- A step MUST produce **exactly one** outcome.
- On any failure, the system MUST stop and transition to **RECORD → RESPOND**.

---

## Proposal

A **Proposal** is a JSON payload generated by the agent (treated as a black box), which must conform to a predefined schema.

### Required Fields

- `schema_version` (e.g., `1.x.x`)
- `id` (UUID)
- `reasoning`(string, non-empty; audit only)
- `action`(string, allowlisted)
- `args`(object, action-specific schema)

---

## Step Lifecycle

### Phase Overview (Strict Order)

Each step **MUST** go through the following phases in order:

1. `RECEIVE` (ingest proposal)
2. `PARSE` (deserialize JSON)
3. `VALIDATE_SCHEMA` (validate top-level schema)
4. `VALIDATE_ACTION` (check action allowlist)
5. `VALIDATE_ARGS` (validate action-specific arguments)
6. `AUTHORIZE` (policy enforcement / sandbox checks)
7. `EXECUTE` (perform action)
8. `RECORD` (logging / trace export)
9. `RESPOND` (return result)

> **Note:** If any phase fails, the system **MUST immediately transition to `RECORD` and `RESPOND`** with the corresponding outcome. Execution **must not continue** to subsequent phases.

---

## Step Lifecycle Phases (Detailed)

### RECEIVE

**Purpose:** Ingest raw proposal and initialize step context.  
**Input:** Raw payload from agent (string / bytes)  
**Output:** `StepContext` initialized with:

- `step_index` (sequential index assigned by runtime)
- `received_at` (timestamp; for logging only, not for decision making)
- `raw_payload` (original string, must be preserved)

**Requirements (MUST):**

- MUST preserve the original payload (immutable)
- MUST generate `step_index`

**Failure Handling:**

- Empty payload or exceeding maximum length → `VALIDATION_ERROR`

---

### PARSE

**Purpose:** Deserialize raw JSON into an object.  
**Input:** `raw_payload`  
**Output:** `proposal_obj` (JSON object)

**Requirements (MUST):**

- MUST use a strict JSON parser
- MUST stop further processing on parse failure

**Failure Handling:**

- JSON parse error → `VALIDATION_ERROR`
- Return message: `"Invalid JSON format"`

---

### VALIDATE_SCHEMA

**Purpose:** Ensure top-level schema integrity and prevent hidden control channels.  
**Input:** `proposal_obj`  
**Output:** `validated_proposal`

**Requirements (MUST):**

- Required fields (must exist and be valid):
  - `schema_version`: string, must match `^1\.\d+\.\d+$`
  - `id`: valid UUID string
  - `reasoning`: string, min length = 1
  - `action`: string (validated in next phase)
  - `args`: object

- MUST reject any unknown top-level fields  
  Allowed keys: `{schema_version, id, reasoning, action, args}`

**Failure Handling:**

- Missing fields / invalid types / invalid schema_version / extra fields → `VALIDATION_ERROR`
- If `id` missing → `proposal_id = null` allowed in response

---

### VALIDATE_ACTION

**Purpose:** Ensure action is registered and allowed.  
**Input:** `validated_proposal.action`  
**Output:** `validated_action`

**Allowed Actions (example):**

- `THINK`, `FINISH`
- `READ_FILE`, `WRITE_FILE`, `DELETE_FILE`, `RENAME_FILE`
- `LIST_FILES`, `CREATE_DIRECTORY`

**Requirements (MUST):**

- MUST enforce `action ∈ allowlist`
- MUST enforce consistent casing (recommend uppercase)

**Failure Handling:**

- Action not allowed → `DENIED`
  - `error_code = "ACTION_NOT_ALLOWED"`

---

### VALIDATE_ARGS

**Purpose:** Strictly validate arguments per action contract.  
**Input:** `validated_proposal.args` + `action`  
**Output:** `validated_args`

**Requirements (MUST):**

- MUST apply per-action schema (contract)
- MUST reject unknown keys (`additionalProperties = false`)
- MUST perform basic path validation:
  - Must be string
  - Must start with `/sandbox/`
  - Must not contain illegal characters (e.g., `\0`)
  - SHOULD flag `..` as invalid (final canonicalization in AUTHORIZE)

**Failure Handling:**

- Missing fields / invalid types / extra fields / invalid format → `VALIDATION_ERROR`

---

### AUTHORIZE

**Purpose:** Enforce security policies before execution.  
**Input:** `action`, `validated_args`, runtime policy config  
**Output:** `authorized_request`

**Requirements (MUST):**

- MUST perform canonical path resolution (prevent traversal attacks)  
  Canonicalize first, then ensure path remains within `/sandbox/`
- MUST enforce file extension restrictions (e.g., `.txt`, `.md`)
- MUST reject any non-sandbox path
- MUST explicitly deny violations (no best-effort execution)

**Failure Handling:**

- Policy or sandbox violation → `DENIED`
  - `error_code = "POLICY_VIOLATION"`

---

### EXECUTE

**Purpose:** Execute the authorized action.  
**Input:** `authorized_request`  
**Output:** `execution_result`

**Requirements (MUST):**

- MUST only execute allowlisted actions
- MUST not escalate privileges or reinterpret intent
- SHOULD map internal exceptions to stable error types

**Failure Handling:**

- I/O or runtime errors → `EXECUTION_ERROR`
  - `error_code = "EXECUTION_ERROR"`

---

### RECORD

**Purpose:** Generate an auditable trace record for each step.  
**Input:** Full `StepContext`  
**Output:** `trace_record`

**Requirements (MUST):**

- MUST record:
  - `step_index`
  - `proposal_id`
  - `schema_version`
  - `action`
  - `args_summary`
  - `outcome`
  - `error_code` (if any)
  - `phase_failed_at` (if failed)
  - timestamps (receive / complete)

- MUST store `reasoning` for audit purposes
- MUST ensure reasoning does NOT affect authorization or execution

**Failure Handling:**

- Logging failure (fatal) → runtime MAY terminate the entire run

---

### RESPOND

**Purpose:** Return a structured step result.  
**Input:** `outcome` + result / error  
**Output:** Structured JSON response

**Requirements (MUST):**

- MUST follow a fixed response schema
- MUST include `proposal_id` (if available)
- MUST include `action` (if available)

---

## Examples

### Example 1: Successful Execution

**Input (Proposal):**

```json
{
  "schema_version": "1.0.0",
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "reasoning": "Need to read a configuration file to proceed.",
  "action": "READ_FILE",
  "args": {
    "path": "/sandbox/config/settings.txt"
  }
}
```

**Output (Response):**

```json
{
  "proposal_id": "550e8400-e29b-41d4-a716-446655440000",
  "action": "READ_FILE",
  "outcome": "SUCCESS",
  "result": {
    "content": "file content here..."
  },
  "error": null
}
```

---

### Example 2: Validation Error — Invalid JSON

**Input:**

```json
{ invalid json }
```

**Output (Response):**

```json
{
  "proposal_id": null,
  "action": null,
  "outcome": "VALIDATION_ERROR",
  "result": null,
  "error": {
    "error_code": "INVALID_JSON",
    "message": "Invalid JSON format"
  }
}
```

---

### Example 3: Execution Error — File Not Found

**Input (Proposal):**

```json
{
  "schema_version": "1.0.0",
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "reasoning": "Need to read a configuration file to proceed.",
  "action": "READ_FILE",
  "args": {
    "path": "/sandbox/nonexistent.txt"
  }
}
```

**Output (Response):**

```json
{
  "proposal_id": "550e8400-e29b-41d4-a716-446655440000",
  "action": "READ_FILE",
  "outcome": "EXECUTION_ERROR",
  "result": null,
  "error": {
    "error_code": "EXECUTION_ERROR",
    "message": "File not found"
  }
}
```
